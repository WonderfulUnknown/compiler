需要注意避免左递归，DFA，NFA，移进规约等理论上的东西

以一个简单的C源程序验证你的语法分析器，可以文本方式输出语法树结构，以节点编号输出父子关系，来验证分析器的正确性，如下例：
main()
{
	int a, b;
	if (a == 0)
		a = b + 1;
}
可能的输出为：
0 : Type Specifier,     integer,       Children:
1 : ID Declaration,     symbol: a      Children:
2 : ID Declaration,     symbol: b      Children:
3 : Var Declaration,                   Children: 0    1    2
4 : ID Declaration,     symbol: a      Children:
5 : Const Declaration,  value:0,       Children:
6 : Expr,               op: ==,        Children: 4    5
7 : ID Declaration,     symbol: a      Children:
8 : ID Declaration,     symbol: b      Children:
9 : Const Declaration,  value:1,       Children:
10: Expr,               op: +,         Children: 8    9
11: Expr,               op: =,         Children: 7    10
12: if statement,                      Children: 6    11
13: compound statement,                Children: 3	  12

problem:
1.行号linenoo失败（目前仅考虑回车时行号++
2.id已有还是会创建结点（若有必要从符号表中找到id指针
3.需要两次后序遍历，先检查后输出结点（尝试一次解决
4.符号表最好用链表来实现

实现类型检查模块：
在上一次作业构造的语法树上进行
后序遍历，实现类型检查、结果类型赋值等，
然后打印出语法树，
对每个结点打印类型信息（类型错误）。

类型检查可能不需要两次遍历输出，在.y文件中进行类型赋值也许可以

在遍历的时候，把控制流语句的false_label赋值成兄弟语句的tag